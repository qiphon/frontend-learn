# reactNative 组件


1. 基础组件

View  相当于div但是点击事件一般不写在这个上面  https://reactnative.cn/docs/view.html
    onStartShouldSetResponder    设置这个视图是否要响应 touch start 事件。 View.props.onStartShouldSetResponder: (event) => [true | false], 其中 event 是一个合成触摸事件。
    accessibilityLabel           可访问性提示可帮助用户了解在对辅助功能元素执行操作时会发生什么情况，当可访问性标签中的结果不明显时。
    accessibilityHint            设置当用户与此元素交互时，“读屏器”（对视力障碍人士的辅助功能）阅读的文字。默认情况下，这个文字会通过遍历所有的子元素并累加所有的文本标签来构建。
    hitSlop                      定义触摸事件在距离视图多远以内时可以触发的。典型的接口规范建议触摸目标至少要 30-40 点/密度-独立像素。触摸范围不会扩展到父视图之外，另外如果触摸到两个重叠的视图，Z-index 高的元素会优先。object: {top: number, left: number, bottom: number, right: number}
    nativeID                     用来从原生类定位这个视图
    onAccessibilityTap           当 accessible 为 true 时，如果用户对一个已选中的无障碍元素做了一个双击手势时，系统会调用此函数。（译注：此事件是针对残障人士，并非是一个普通的点击事件。如果要为 View 添加普通点击事件，请直接使用 Touchable 系列组件替代 View，然后添加 onPress 函数）。
    onLayout                     当组件挂载或者布局变化的时候调用.这个事件会在布局计算完成后立即调用一次，不过收到此事件时新的布局可能还没有在屏幕上呈现，尤其是一个布局动画正在进行中的时候
    onMagicTap                   当 accessible 为 true 时，如果用户做了一个双指轻触(Magic tap)手势，系统会调用此函数。
    onMoveShouldSetResponder     这个视图想要“认领”这个 touch move 事件吗？每当有 touch move 事件在这个视图中发生，并且这个视图没有被设置为这个 touch move 的响应时，这个函数就会被调用。View.props.onMoveShouldSetResponder: (event) => [true | false], 其中 event 是一个合成触摸事件
    onMoveShouldSetResponderCapture    如果父视图想要阻止子视图响应 touch move 事件时，它就应该设置这个方法并返回 true
    onResponderGrant                   这个视图开始响应触摸事件。此时需要高亮告诉用户正在响应。（译者注：对于大部分的触摸处理，你只需要用 TouchableHighlight 或 TouchableOpacity 包装你的组件。阅读 Touchable.js。）
    onResponderMove                    当用户正在屏幕上移动手指时调用这个函数。
    onResponderReject                  有一个响应器正处于活跃状态，并且不会向另一个要求响应这个事件的视图释放这个事件。
    onResponderRelease                 在整个触摸事件结束时调用这个函数。
    onResponderTerminate               响应被从这个视图上“劫走”了。可能是在调用了 onResponderTerminationRequest 之后，被另一个视图“劫走”了（见 onresponderterminationrequest), 也可能是由于 OS 无条件终止了响应（比如说被 iOS 上的控制中心／消息中心）
    onResponderTerminationRequest      其他某个视图想要成为事件的响应者，并要求这个视图放弃对事件的响应时，就会调用这个函数。如果允许释放响应，就返回true。
    accessible                         当此属性为 true 时，表示此视图是一个启用了无障碍功能的元素。默认情况下，所有可触摸操作的元素都是无障碍功能元素。
    onStartShouldSetResponderCapture   如果父视图想要阻止子视图响应 touch start 事件，它就应该设置这个方法并返回 true。
    pointerEvents                      用于控制当前视图是否可以作为触控事件的目标。
                                        auto：视图可以作为触控事件的目标。
                                        none：视图不能作为触控事件的目标。
                                        box-none：视图自身不能作为触控事件的目标，但其子视图可以
                                        'box-only':视图自身可以作为触控事件的目标，但其子视图不能
                                        类似于你在 CSS 中这样设置:
                                        ```
                                        // box-none
                                        .box-none {
                                            pointer-events: none;
                                        }
                                        .box-none * {
                                            pointer-events: all;
                                        }

                                        // box-only
                                        .box-only {
                                            pointer-events: all;
                                        }
                                        .box-only * {
                                            pointer-events: none;
                                        }
  
                                        ```
    removeClippedSubviews             这是一个特殊的性能相关的属性，由 RCTView 导出。在制作滑动控件时，如果控件有很多不在屏幕内的子视图，会非常有用。要让此属性生效，首先要求视图有很多超出范围的子视图，并且子视图和容器视图（或它的某个祖先视图）都应该有样式 overflow: hidden。
    style                             不解释
    testID                            用来在端到端测试中定位这个视图。
    accessibilityComponentType        使无障碍服务对这个 UI 组件与原生组件一致处理。仅对 Android 平台有效。
    accessibilityLiveRegion           告知无障碍服务当此视图更新时，是否要通知用户。只对 Android API >= 19 的设备有效
    collapsable                       如果一个 View 只用于布局它的子组件，则它可能会为了优化而从原生布局树中移除。 把此属性设为 false 可以禁用这个优化，以确保对应视图在原生结构中存在。
    importantForAccessibility         控制一个视图在无障碍功能中有多重要：它是否产生一个辅助功能事件，以及它是否能被请求屏幕内容的无障碍服务知晓。只对 Android 平台生效。
    needsOffscreenAlphaCompositing    决定这个视图是否要先离屏渲染再进行半透明度处理，来确保颜色和混合效果正确。默认值(false) 有性能问题
    renderToHardwareTextureAndroid    决定这个视图是否要把它自己（以及所有的子视图）渲染到一个 GPU 上的硬件纹理中。
    accessibilityRole                 
    accessibilityStates
    accessibilityTraits
    accessibilityViewIsModal
    accessibilityElementsHidden
    accessibilityIgnoresInvertColors
    shouldRasterizeIOS               决定这个视图是否需要在被混合之前绘制到一个位图上。
-----------------------------------
Text  一个用于显示文本的React组件，并且它也支持嵌套、样式，以及触摸处理。<Text>元素在布局上不同于其它组件：在Text内部的元素不再使用flexbox布局，而是采用文本布局。这意味着<Text>内部的元素不再是一个个矩形，而可能会在行末进行折叠。
      可以相互嵌套
      在React Native中，我们把这个问题设计的更加严谨：你必须把你的文本节点放在<Text>组件内。你不能直接在<View>下放置一段文本！
      不能直接设置一整颗子树的默认样式。使用一个一致的文本和尺寸的推荐方式是创建一个包含相关样式的组件MyAppText，然后在你的App中反复使用它。你还可以创建更多特殊的组件譬如MyAppHeaderText来表达不同样式的文本

      ```
      <Text>
        <Text>
        </Text>
      </Text>

      // Text中也可以嵌入view 。 但这仅仅在iOS中，但是如果这样用View必须设置宽和高
      <Text>
        <View 
          style={{width: 50, height: 50, backgroundColor: 'steelblue'}} 
        >
        </View>
      </Text>

      // 不同文本的样式表示方法：（不同的组件写好不同的样式）
      <View>
        <MyAppText>这个组件包含了一个默认的字体样式，用于整个应用的文本</MyAppText>
        <MyAppHeaderText>这个组件包含了用于标题的样式</MyAppHeaderText>
      </View>

      // 子Text标签只会继承父Text标签的样式属性

      ```
      查看Props
        View props...  view的props都支持
        selectable           决定用户是否可以长按选择文本，以便复制和粘贴。
        accessibilityHint   
        accessibilityLabel
        accessible
        ellipsizeMode        这个属性通常和下面的 numberOfLines 属性配合使用，表示当 Text 组件无法全部显示需要显示的字符串时如何用省略号进行修饰。
                              head - 从文本内容头部截取显示省略号。例如： "...efg"
                              middle - 在文本内容中间截取显示省略号。例如： "ab...yz"
                              tail - 从文本内容尾部截取显示省略号。例如： "abcd..."
                              clip - 不显示省略号，直接从尾部截断。
        nativeID
        numberOfLines        用来当文本过长的时候裁剪文本。包括折叠产生的换行在内，总的行数不会超过这个属性的限制。此属性一般和ellipsizeMode搭配使用。Number
        onLayout             在加载时或者布局变化以后调用，参数为如下的内容{nativeEvent: {layout: {x, y, width, height}}}
        onLongPress          当文本被长按以后调用此回调函数。
        onPress              当文本被点击以后调用此回调函数。
        pressRetentionOffset
        allowFontScaling     控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。
        style
        testID
        disabled
        selectionColor       文本的高亮颜色
        textBreakStrategy
        adjustsFontSizeToFit   指定字体是否随着给定样式的限制而自动缩放。
        minimumFontScale       当adjustsFontSizeToFit开启时，指定最小的缩放比（即不能低于这个值）。可设定的值为0.01 - 1.
        suppressHighlighting   设为true时，当文本被按下会没有任何视觉效果。默认情况下，文本被按下时会有一个灰色的、椭圆形的高光。

      地址 https://reactnative.cn/docs/text.html
------------------------------
Image  用于显示多种不同类型图片的 React 组件，包括网络图片、静态资源、临时的本地图片、以及本地磁盘上的图片（如相册）等。
    添加或修改img时，最好禁用热加载，服务容易挂掉
    图片文件的查找会和 JS 模块的查找方式一样。在上面的这个例子里，是哪个组件引用了这个图片，Packager 就会去这个组件所在的文件夹下查找my-icon.png。并且，如果你有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件。
    你还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片。比如下面这样的代码结构：

    ```
      <Image source={require('./img/check.png')} />

      ├── button.js
      └── img
          ├── check.png
          ├── check@2x.png
          └── check@3x.png

    ```
    ! 注意：为了使新的图片资源机制正常工作，require 中的图片名字必须是一个静态字符串（不能使用变量！因为 require 是在编译时期执行，而非运行时期执行！）。

    ```
    // 正确
    <Image source={require('./my-icon.png')} />;

    // 错误
    var icon = this.props.active ? 'my-icon-active' : 'my-icon-inactive';
    <Image source={require('./' + icon + '.png')} />;

    // 正确
    var icon = this.props.active
      ? require('./my-icon-active.png')
      : require('./my-icon-inactive.png');
    <Image source={icon} />;

    ```
    使用混合 App 的图片资源
    如果你在编写一个混合 App（一部分 UI 使用 React Native，而另一部分使用平台原生代码），也可以使用已经打包到 App 中的图片资源（以拖拽的方式放置在 Xcode 的 asset 类目中，或是放置在 Android 的 drawable 目录里）。注意此时只使用文件名，不带路径也不带后缀：

    ```
    <Image source={{uri: 'app_icon'}} style={{width: 40, height: 40}} />

    ```
    对于放置在 Android 的 assets 目录中的图片，还可以使用asset:/ 前缀来引用：

    ```
    <Image source={{uri: 'asset:/app_icon.png'}} style={{width: 40, height: 40}} />

    ```
    注意：这些做法并没有任何安全检查。你需要自己确保图片在应用中确实存在，而且还需要指定尺寸。
    网络图片
    很多要在 App 中显示的图片并不能在编译的时候获得，又或者有时候需要动态载入来减少打包后的二进制文件的大小。这些时候，与静态资源不同的是，你需要手动指定图片的尺寸。同时我们强烈建议你使用 https 以满足 iOS App Transport Security 的要求。

    ```
    // 正确
    <Image source={{uri: 'https://facebook.github.io/react/logo-og.png'}}
          style={{width: 400, height: 400}} />

    // 错误
    <Image source={{uri: 'https://facebook.github.io/react/logo-og.png'}} />

    // 你可以在 Image 组件的 source 属性中指定一些请求参数，如下面的示例：

    <Image
      source={{
        uri: 'https://facebook.github.io/react/logo-og.png',
        method: 'POST',
        headers: {
          Pragma: 'no-cache',
        },
        body: 'Your Body goes here',
      }}
      style={{width: 400, height: 400}}
    />


    // base64 数据形式的图片，此时可以使用'data:'格式来显示图片。请注意，你需要手动指定图片的尺寸。
    // 请记得指定宽高！建议仅对非常小的图片使用 base64 数据，比如一些小图标。
    <Image
      style={{
        width: 51,
        height: 51,
        resizeMode: 'contain',
      }}
      source={{
        uri:
          'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==',
      }}
    />

    ```
    缓存控制（仅 iOS）
    在某些情况下你可能仅仅想展示一张已经在本地缓存的图片，例如一个低分辨率的占位符，直到高分辨率的图片可用。又或者你无所谓图片是否过时，而且也不在乎显示过时的图片，节省带宽相对更重要。缓存资源属性提供给了你控制网络层与缓存交互的方式。
    1. default: 使用原生平台默认策略。
    2. reload: URL 的数据将从原始地址加载。不使用现有的缓存数据。
    3. force-cache: 现有的缓存数据将用于满足请求，忽略其期限或到期日。如果缓存中没有对应请求的数据，则从原始地址加载。
    4. only-if-cached: 现有的缓存数据将用于满足请求，忽略其期限或到期日。如果缓存中没有对应请求的数据，则不尝试从原始地址加载，并且认为请求是失败的。

    ```
    <Image
      source={{
        uri: 'https://facebook.github.io/react/logo-og.png',
        cache: 'only-if-cached',
      }}
      style={{width: 400, height: 400}}
    />

    ```
    为什么不在所有情况下都自动指定尺寸呢?
    在浏览器中，如果你不给图片指定尺寸，那么浏览器会首先渲染一个 0x0 大小的元素占位，然后下载图片，在下载完成后再基于正确的尺寸来渲染图片。这样做的最大问题是 UI 会在图片加载的过程中上下跳动，使得用户体验非常糟糕。

    在React Native中我们有意避免了这一行为。如此一来开发者就需要做更多工作来提前知晓远程图片的尺寸（或宽高比），但我们相信这样可以带来更好的用户体验。然而，读取本地静态图片（使用require('./my-icon.png')语法）则无需指定尺寸，因为它们的尺寸在加载时就可以立刻知道。

    本地文件系统中的图片
    参考[相册（CameraRoll)](https://reactnative.cn/docs/cameraroll)这个例子来看如何使用在Images.xcassets以外的本地资源。

    背景图片与嵌套写法
    开发者们常面对的一种需求就是类似 web 中的背景图（background-image）。要实现这一用例，只需使用<ImageBackground>组件（其 props 与<Image>完全相同），然后把需要背景图的子组件嵌入其中即可。

    也可能你并不需要使用<ImageBackground>，因为它的实现其实非常简单，实质就是对图片使用了绝对定位。你可以阅读其文档然后思考你是否有更好更简单的布局方案。同样，需要制定图片宽和高

    ```
    return (
      <ImageBackground source={...} style={{width: '100%', height: '100%'}}>
        <Text>Inside</Text>
      </ImageBackground>
    );

    ```

    iOS 边框圆角的注意事项
    请注意下列边框圆角样式目前在 iOS 的图片组件上还不支持：

    borderTopLeftRadius
    borderTopRightRadius
    borderBottomLeftRadius
    borderBottomRightRadius

    在 Android 上支持 GIF 和 WebP 格式图片
    默认情况下 Android 是不支持 GIF 和 WebP 格式的。你需要在android/app/build.gradle文件中根据需要手动添加以下模块：

    ```
    dependencies {
      // 如果你需要支持Android4.0(API level 14)之前的版本 （这个我没有下载下来，不知道为什么）
      // implementation "com.facebook.fresco:animated-base-support:1.10.0"

      // 如果你需要支持GIF动图
      implementation "com.facebook.fresco:animated-gif:1.10.0"

      // 如果你需要支持WebP格式，包括WebP动图
      implementation "com.facebook.fresco:animated-webp:1.10.0"
      implementation "com.facebook.fresco:webpsupport:1.10.0"

      // 如果只需要支持WebP格式而不需要动图
      implementation "com.facebook.fresco:webpsupport:1.10.0"
    }

    ```
    image的属性和方法汇总 https://reactnative.cn/docs/image.html

    Props
      View props...  view的props都支持
      style
      blurRadius
      onLayout
      onLoad
      onLoadEnd
      onLoadStart
      resizeMode            // contain, cover, stretch, center, repeat
      source
      loadingIndicatorSource
      onError
      testID
      resizeMethod
      accessibilityLabel
      accessible
      capInsets
      defaultSource
      onPartialLoad
      onProgress
      fadeDuration
      progressiveRenderingEnabled
    Methods
      getSize
      prefetch
      abortPrefetch
      queryCache
      resolveAssetSource


TextInput  文本输入框

    > TextInput是一个允许用户在应用中通过键盘输入文本的基本组件。本组件的属性提供了多种特性的配置，譬如自动完成、自动大小写、占位文字，以及多种不同的键盘类型（如纯数字键盘）等等。
    最简单的用法就是丢一个TextInput到应用里，然后订阅它的onChangeText事件来读取用户的输入。注意，从TextInput里取值这就是目前唯一的做法！

    注意有些属性仅在multiline为true或者为false的时候有效。此外，当multiline=false时，为元素的某一个边添加边框样式（例如：borderBottomColor，borderLeftWidth等）将不会生效。为了能够实现效果你可以使用一个View来包裹TextInput：

    ```
    import React, { Component } from 'react';
    import { View, TextInput } from 'react-native';

    class UselessTextInput extends Component {
      render() {
        return (
          <TextInput
            {...this.props} // 将父组件传递来的所有props传递给TextInput;比如下面的multiline和numberOfLines
            editable = {true}
            maxLength = {40}
          />
        );
      }
    }

    export default class UselessTextInputMultiline extends Component {
      constructor(props) {
        super(props);
        this.state = {
          text: 'Useless Multiline Placeholder',
        };
      }

      // 你可以试着输入一种颜色，比如red，那么这个red就会作用到View的背景色样式上
      render() {
        return (
        <View style={{
          backgroundColor: this.state.text,
          borderBottomColor: '#000000',
          borderBottomWidth: 1 }}
        >
          <UselessTextInput
            multiline = {true}
            numberOfLines = {4}
            onChangeText={(text) => this.setState({text})}
            value={this.state.text}
          />
        </View>
        );
      }
    }

    ```
    查看Props
      View props...  view的props都支持
      allowFontScaling                 控制字体是否要根据系统的“字体大小”辅助选项来进行缩放。默认值为true。
      autoCapitalize                   控制TextInput是否要自动将特定字符切换为大写，This property is not supported by some keyboard types such as name-phone-pad.
                                        characters: 所有的字符。
                                        words: 每个单词的第一个字符。
                                        sentences: 每句话的第一个字符（默认）。
                                        none: 不切换。
      autoComplete                    自动完成 Android默认开启 仅Android
                                      enum('off', 'username', 'password', 'email', 'name', 'tel', 'street-address', 'postal-code', 'cc-number', 'cc-csc', 'cc-exp', 'cc-exp-month', 'cc-exp-year')  
      autoCorrect                     如果为false，会关闭拼写自动修正。默认值是true。
      autoFocus                       componentDidMount 后会自动获得焦点，默认false
      blurOnSubmit                    如果为true，文本框会在提交的时候失焦。对于单行输入框默认值为true，多行则为false。注意：对于多行输入框来说，如果将blurOnSubmit设为true，则在按下回车键时就会失去焦点同时触发onSubmitEditing事件，而不会换行。

      caretHidden                     如果为true，则隐藏光标。默认值为false。
      clearButtonMode                 仅iOS 是否要在文本框右侧显示“清除”按钮。仅在单行模式下可用。默认值为never。enum('never', 'while-editing', 'unless-editing', 'always')
      clearTextOnFocus                仅iOS 如果为true，每次开始输入的时候都会清除文本框的内容。      
      contextMenuHidden               If true, context menu is hidden. The default value is false.
      dataDetectorTypes               仅iOS 设置 text input 内能被转化为可点击URL的数据的类型。当且仅当multiline={true}和editable={false}时起作用。默认情况下不检测任何数据类型。
                                      可接受一个类型值或类型值数组。
      defaultValue                    提供一个文本框中的初始值。当用户开始输入的时候，值就可以改变。在一些简单的使用情形下，如果你不想用监听消息然后更新value属性的方法来保持属性和状态同步的时候，就可以用defaultValue来代替。
      
      disableFullscreenUI
      editable
      enablesReturnKeyAutomatically
      inlineImageLeft
      inlineImagePadding
      keyboardAppearance
      keyboardType
      maxLength
      multiline
      numberOfLines
      onBlur
      onChange
      onChangeText
      onContentSizeChange
      onEndEditing
      onFocus
      onKeyPress
      onLayout
      onScroll
      onSelectionChange
      onSubmitEditing
      placeholder
      placeholderTextColor
      returnKeyLabel
      returnKeyType
      scrollEnabled
      secureTextEntry
      selection
      selectionColor
      selectionState
      selectTextOnFocus
      spellCheck
      style
      textContentType
      textBreakStrategy
      underlineColorAndroid
      value
      查看方法
      clear
      isFocused
    

地址 https://reactnative.cn/docs/textinput.html
-----------------------------
ScrollView  可滚动的视图容器
StyleSheet  css样式都需要用它来创建

2. 交互控件

Button  按钮
Picker  选择器控件（iOS/Android）原生
Slider  滑动数值选择器
Switch  开关控件

3. 列表视图

FlatList  高性能的滚动列表组件
SectionList  类似FlatList，但是多了分组显示

4. 其他

ActivityIndicator  显示圆形正在加载符号
Alert              弹出提示框，显示指定标题和信息
Animated           动画库
CameraRoll         可访问相册
Clipboard          读写剪贴板
Dimensions         获取设备尺寸
KeyboardAvoidingView 一种视图容器，可以随键盘升起而移动
Linking            提供通用接口调起其他应用或被其他应用调起
Modal              模态框
PixelRatio         获取像素密度
RefreshControl     用于在scrollview中添加下拉刷新功能而衍生的组件
StatusBar          应用顶部状态栏样式的组件
Webview            在原生视图组件中显示web内容的组件

### 静态的非图片资源
上面描述的require语法也可以用来静态地加载你项目中的声音、视频或者文档文件。大多数常见文件类型都支持，包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等（完整列表请看 [packager defaults](https://github.com/facebook/metro/blob/master/packages/metro-config/src/defaults/defaults.js#L14-L44))。

你也可以创建自己的配置文件来支持其他类型的文件。具体的配置可以参考[packager config file](https://github.com/facebook/react-native/blob/0.57-stable/local-cli/util/Config.js#L65)。

需要注意的是视频必须指定尺寸而不能使用flex样式，因为我们目前还不能从非图片资源中获取到尺寸信息。对于直接链接到 Xcode 或者 Android 资源文件夹的视频，则不会有这个限制。

#### TextInput 文本输入框

```
<TextInput
    style={{
    width:'100%'
    }}
    placeholder="input demo"
    onChangeText= { text=>this.inputChange(text) }
></TextInput>

```

> TextInput是一个允许用户输入文本的基础组件。它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。

#### Alert 警告弹窗

```
<Button
  onPress={() => {
    Alert.alert("你点击了按钮！");
  }}
  title="点我！"
/>

```
#### Touchable 系列组件

```
这个组件的样式是固定的。所以如果它的外观并不怎么搭配你的设计，那就需要使用TouchableOpacity或是TouchableNativeFeedback组件来定制自己所需要的按钮，视频教程[如何制作一个按钮讲述了完整的过程](http://v.youku.com/v_show/id_XMTQ5OTE3MjkzNg==.html?f=26822355&from=y1.7-1.3)。或者你也可以在 github.com 网站上搜索 'react native button' 来看看社区其他人的作品。

```

#### Button 按钮组件

```
export default class App extends Component<Props> {
  inputChange(text) {
    console.warn(text)
  }
  _onPressButton() {
    Alert.alert('You tapped the button!')
  }
  render() {
    return (
      <View style={styles.container}>
        <View style={styles.buttonContainer}>
          <Button
            onPress={this._onPressButton}
            title="Press Me"
          />
        </View>
        <View style={styles.buttonContainer}>
          <Button
            onPress={this._onPressButton}
            title="Press Me"
            color="#841584"
          />
        </View>
        <View style={styles.alternativeLayoutButtonContainer}>
          <Button
            onPress={this._onPressButton}
            title="This looks great!"
          />
          <Button
            onPress={this._onPressButton}
            title="OK!"
            color="#841584"
          />
        </View>
      </View>
    );
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
  },
  buttonContainer: {
    margin: 20
  },
  alternativeLayoutButtonContainer: {
    margin: 20,
    flexDirection: 'row',
    justifyContent: 'space-between'
  }
});


```